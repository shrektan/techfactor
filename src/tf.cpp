/*
 * Design:
 *
 * - the date sequences here must be contious trading date sequence, we also have a converter
 *   so that locate a special date is fast and easy
 * - the option to use single pass algo to boost the performance
 *   __UPDATE__: difficult to do it generally and may not neccessary since many calculations
 *   are very small except for the regression stuff.
 * - any NA in the input will lead to NA in the output
 * - support concurrency for different codes. It means we can calculate different codes at the
 *   same time. However, you can't calculate the same codes for different date parrellely.
 */


#include <Rcpp.h>
#include "algo.h"

extern std::map<std::string, Alpha_fun&> tf_caculators;
extern std::map<std::string, Alpha_mfun&> tf_mcaculators;


// [[Rcpp::export]]
Rcpp::NumericMatrix create_xts(Rcpp::NumericMatrix x_mat, Rcpp::newDateVector x_dates)
{
  Rcpp::NumericVector dates = Rcpp::clone(x_dates) * 86400;
  dates.attr("tzone") = "UTC";
  dates.attr("tclass") = "Date";

  Rcpp::NumericMatrix mat = Rcpp::clone(x_mat);
  if (!Rf_isNull(mat.attr("dimnames"))) {
    Rcpp::List dimnames = mat.attr("dimnames");
    if (dimnames.size() != 2) Rcpp::stop(
      "weird to find dimnames size is %d (expect 2)."
    );
    dimnames[0] = R_NilValue;
  }
  mat.attr("index") = dates;
  mat.attr("class") = Rcpp::CharacterVector::create("xts", "zoo");
  mat.attr(".indexCLASS") = "Date";
  mat.attr("tclass") = "Date";
  mat.attr(".indexTZ") = "UTC";
  mat.attr("tzone") = "UTC";
  return mat;
}


//' The registered factor names
//'
//' Return all the factor names that are registered in the C++ routine.
//'
//' @export
// [[Rcpp::export]]
Rcpp::List tf_reg_factors()
{
  using namespace Rcpp;
  std::vector<std::string> factors;
  for (auto& elem : tf_caculators) factors.push_back(elem.first);
  std::vector<std::string> mfactors;
  for (auto& elem : tf_mcaculators) mfactors.push_back(elem.first);
  return List::create(
    _["factor"] = factors,
    _["mfactors"] = mfactors
  );
}


//' The quote external pointer
//'
//' @param qt_tbl A `data.frame` contains the daily price info
//'   of a security. It must contain a column `DATE` and 10 numeric
//'   columns `PCLOSE`, `OPEN`, `HIGH`, `LOW`, `CLOSE`, `VWAP`,
//'   `VOLUME`, `AMOUNT`, `BMK_CLOSE`, `BMK_OPEN`. Moreover, the
//'   column `DATE` must be in ascending order.
//'
//' @return An R external pointer than can hold a `Quote` object.
//' @export
// [[Rcpp::export]]
SEXP tf_quote_xptr(Rcpp::DataFrame qt_tbl)
{
  Quote* ptr = new Quote {qt_tbl};
  return Rcpp::XPtr<Quote>(ptr, true);
}


//' @rdname tf_quote_xptr
//' @export
// [[Rcpp::export]]
SEXP tf_quotes_xptr(Rcpp::List qt_tbls)
{
  Quotes* ptr = new Quotes {qt_tbls};
  return Rcpp::XPtr<Quotes>(ptr, true);
}


//' Calculate the technical factor (TF)
//'
//' @param qt_ptr An R external pointer generated by [tf_quote_xptr()].
//' @param names A character vector in which all the elements are registered.
//' @param from_to A length two `Date` vector whose first element must be
//'   smaller than or equal to the first.
//'
//' @return A `data.frame` with two columns `DATE` and `VALUE` . The order
//'   of column `DATE` must be in ascending order.
//' @export
// [[Rcpp::export]]
Rcpp::NumericMatrix tf_qt_cal(SEXP qt_ptr, Rcpp::StringVector names, Rcpp::newDateVector from_to)
{
  using namespace Rcpp;
  assert_valid(from_to);
  XPtr<Quote> qt_xptr {qt_ptr};
  auto& qt = *qt_xptr;

  const auto dates = qt.tdates(from_to);
  NumericMatrix res(dates.size(), names.size());

  auto res_iter = res.begin();
  for (auto c_name : names) {
    const std::string name {c_name};
    if (tf_caculators.count(name)) {
      auto calculator = tf_caculators.at(name);
      std::transform(
        dates.cbegin(), dates.cend(), res_iter,
        [&qt, &calculator] (const RDate date) {
          qt.set(date);
          return calculator(qt);
        }
      );
      std::advance(res_iter, dates.size());
    }
    else {
      if (tf_mcaculators.count(name)) {
        stop("factor %s can only be used in tf_mcal()", name);
      } else {
        stop("factor %s must be defined before using.", name);
      }
    }
  }

  newDateVector r_dates(dates.size());
  std::copy(dates.cbegin(), dates.cend(), r_dates.begin());
  res.attr("dimnames") = Rcpp::List::create(R_NilValue, names);
  return create_xts(res, r_dates);
}
