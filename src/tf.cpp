/*
 * Design:
 *
 * - the date sequences here must be contious trading date sequence, we also have a converter
 *   so that locate a special date is fast and easy
 * - the option to use single pass algo to boost the performance
 *   __UPDATE__: difficult to do it generally and may not neccessary since many calculations
 *   are very small except for the regression stuff.
 * - any NA in the input will lead to NA in the output
 * - support concurrency for different codes. It means we can calculate different codes at the
 *   same time. However, you can't calculate the same codes for different date parrellely.
 */


#include <Rcpp.h>
#include "algo.h"

extern std::map<std::string, Alpha_fun&> tf_caculators;
extern std::map<std::string, Alpha_mfun&> tf_mcaculators;

//' The registered factor names
//'
//' Return all the factor names that are registered in the C++ routine.
//'
//' @export
// [[Rcpp::export]]
Rcpp::List tf_reg_factors()
{
  using namespace Rcpp;
  std::vector<std::string> factors;
  for (auto& elem : tf_caculators) factors.push_back(elem.first);
  std::vector<std::string> mfactors;
  for (auto& elem : tf_mcaculators) mfactors.push_back(elem.first);
  return List::create(
    _["factor"] = factors,
    _["mfactors"] = mfactors
  );
}


//' The quote external pointer
//'
//' @param qt_tbl A `data.frame` contains the daily price info
//'   of a security. It must contain a column `DATE` and 10 numeric
//'   columns `PCLOSE`, `OPEN`, `HIGH`, `LOW`, `CLOSE`, `VWAP`,
//'   `VOLUME`, `AMOUNT`, `BMK_CLOSE`, `BMK_OPEN`. Moreover, the
//'   column `DATE` must be in ascending order.
//'
//' @return An R external pointer than can hold a `Quote` object.
//' @export
// [[Rcpp::export]]
SEXP tf_quote_xptr(Rcpp::DataFrame qt_tbl)
{
  Quote* ptr = new Quote {qt_tbl};
  return Rcpp::XPtr<Quote>(ptr, true);
}


//' @rdname tf_quote_xptr
//' @export
// [[Rcpp::export]]
SEXP tf_quotes_xptr(Rcpp::List qt_tbls)
{
  Quotes* ptr = new Quotes {qt_tbls};
  return Rcpp::XPtr<Quotes>(ptr, true);
}


//' Calculate the technical factor (TF)
//'
//' @param qt_ptr An R external pointer generated by [tf_quote_xptr()].
//' @param name A registered factor name.
//' @param from_to A length two `Date` vector whose first element must be
//'   smaller than or equal to the first.
//'
//' @return A `data.frame` with two columns `DATE` and `VALUE` . The order
//'   of column `DATE` must be in ascending order.
//' @export
// [[Rcpp::export]]
Rcpp::List tf_cal(SEXP qt_ptr, std::string name, Rcpp::newDateVector from_to)
{
  using namespace Rcpp;
  assert_valid(from_to);
  XPtr<Quote> qt_xptr {qt_ptr};
  auto& qt = *qt_xptr;
  if (tf_caculators.count(name)) {
    auto calculator = tf_caculators.at(name);
    const auto dates = qt.tdates(from_to);
    NumericVector vec(dates.size());
    std::transform(
      dates.cbegin(), dates.cend(), vec.begin(),
      [&qt, &calculator] (const RDate date) {
        qt.set(date);
        return calculator(qt);
      }
    );
    newDateVector r_dates(dates.size());
    std::copy(dates.cbegin(), dates.cend(), r_dates.begin());
    return DataFrame::create(_["DATE"] = r_dates, _["VALUE"] = vec);
  }
  else {
    if (tf_mcaculators.count(name)) {
      stop("factor %s can only be used in tf_mcal()", name);
    } else {
      stop("factor %s must be defined before using.", name);
    }
  }
}


// [[Rcpp::export]]
Rcpp::NumericMatrix create_xts(Rcpp::NumericMatrix x_mat, Rcpp::newDateVector x_dates)
{
  Rcpp::NumericVector dates = Rcpp::clone(x_dates) * 86400;
  dates.attr("tzone") = "UTC";
  dates.attr("tclass") = "Date";

  Rcpp::NumericMatrix mat = Rcpp::clone(x_mat);
  mat.attr("dimnames") = Rcpp::List::create(R_NilValue, Rcpp::colnames(mat));
  mat.attr("index") = dates;
  mat.attr("class") = Rcpp::CharacterVector::create("xts", "zoo");
  mat.attr(".indexCLASS") = "Date";
  mat.attr("tclass") = "Date";
  mat.attr(".indexTZ") = "UTC";
  mat.attr("tzone") = "UTC";
  return mat;
}


//' @rdname
//' @export
// [[Rcpp::export]]
Rcpp::List tf_mcal(SEXP qts_ptr, std::string name, Rcpp::newDateVector from_to)
{
  using namespace Rcpp;
  assert_valid(from_to);
  XPtr<Quotes> qts_xptr {qts_ptr};
  auto& qts = *qts_xptr;
}

