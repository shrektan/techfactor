/*
 * Design:
 *
 * - the date sequences here must be contious trading date sequence, we also have a converter
 *   so that locate a special date is fast and easy
 * - the option to use single pass algo to boost the performance
 *   __UPDATE__: difficult to do it generally and may not neccessary since many calculations
 *   are very small except for the regression stuff.
 * - any NA in the input will lead to NA in the output
 * - support concurrency for different codes. It means we can calculate different codes at the
 *   same time. However, you can't calculate the same codes for different date parrellely.
 */


#include <Rcpp.h>
#include "algo.h"

extern std::map<std::string, Alpha_fun&> tf_caculators;

extern std::map<
  std::string,
  std::function<Rcpp::DataFrame(Quote&, const Rcpp::newDateVector)>
> tf_fast_caculators;


//' The registered factor names
//'
//' Return all the factor names that are registered in the C++ routine.
//'
//' @export
// [[Rcpp::export]]
Rcpp::StringVector tf_reg_factors()
{
  std::set<std::string> names;
  for (auto& elem : tf_caculators) names.insert(elem.first);
  for (auto& elem : tf_fast_caculators) names.insert(elem.first);
  Rcpp::StringVector res(names.size());
  std::copy(names.begin(), names.end(), res.begin());
  return res;
}


//' The quote external pointer
//'
//' @param qt_tbl A `data.frame` contains the daily price info
//'   of a security. It must contain a column `DATE` and 10 numeric
//'   columns `PCLOSE`, `OPEN`, `HIGH`, `LOW`, `CLOSE`, `VWAP`,
//'   `VOLUME`, `AMOUNT`, `BMK_CLOSE`, `BMK_OPEN`. Moreover, the
//'   column `DATE` must be in ascending order.
//'
//' @return An R external pointer than can hold a `Quote` object.
//' @export
// [[Rcpp::export]]
SEXP tf_quote_xptr(Rcpp::DataFrame qt_tbl)
{
  Quote* ptr = new Quote {qt_tbl};
  return Rcpp::XPtr<Quote>(ptr, true);
}


//' Calculate the technical factor (TF)
//'
//' @param qt_ptr An R external pointer generated by [tf_quote_xptr()].
//' @param name A registered factor name.
//' @param from_to A length two `Date` vector whose first element must be
//'   smaller than or equal to the first.
//'
//' @return A `data.frame` with two columns `DATE` and `VALUE` . The order
//'   of column `DATE` must be in ascending order.
//' @export
// [[Rcpp::export]]
Rcpp::List tf_cal(SEXP qt_ptr, std::string name, Rcpp::newDateVector from_to)
{
  using namespace Rcpp;
  assert_valid(from_to);
  XPtr<Quote> qt_xptr {qt_ptr};
  auto& qt = *qt_xptr;
  if (tf_fast_caculators.count(name)) {
    return tf_fast_caculators.at(name)(qt, from_to);
  }
  else if (tf_caculators.count(name)) {
    auto calculator = tf_caculators.at(name);
    const auto dates = qt.tdates(from_to);
    NumericVector vec(dates.size());
    std::transform(
      dates.cbegin(), dates.cend(), vec.begin(),
      [&qt, &calculator] (const RDate date) {
        qt.set(date);
        return calculator(qt);
      }
    );
    newDateVector r_dates(dates.size());
    std::copy(dates.cbegin(), dates.cend(), r_dates.begin());
    return DataFrame::create(_["DATE"] = r_dates, _["VALUE"] = vec);
  }
  else {
    stop("factor %s must be defined before using.", name);
  }
}
